# 2장 입출금 내역 분석기

## 2장 요구사항

```spreadsheet
30-01-2017,-100,Deliveroo
30-01-2017,-50,Tesco
01-02-2017,6000,Salary
02-02-2017,2000,Royalties
02-02-2017,-4000,Rent
03-02-2017,3000,Tesco
05-02-2017,-30,Cinema
```

-   은행 입출금 내역의 총 수입과 총 지출은 각각 얼마인가? 결과가 양수인가 음수인가?
-   특정 달엔 몇 건의 입출금 내역이 발생했는가?
-   지출이 가장 높은 상위 10건은 무엇인가?
-   돈을 가장 많이 소비하는 항목은 무엇인가?

## 2장 원칙

-   KISS : keep it short and simple
    -   처음엔 우선 간단하게 구현해보자.
-   code maintainability (코드 유지보수성)
    -   특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야 한다.
    -   코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야 한다.
    -   새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야 한다.
    -   **캡슐화**가 잘 되어 있어야 한다. 즉 코드 사용자에게는 세부 구현 내용이 감춰져 있으므로 사용자가 쉽게 코드를 이해하고, 기능을 바꿀 수 있어야 한다.
-   anti-pattern (안티 패턴)
    -   한 개의 거대한 **갓 클래스**(god class) 때문에 코드를 이해하기가 어렵다.
    -   **코드 중복**(code duplication) 때문에 코드가 불안정하고 변화에 쉽게 망가진다.
-   DRY : don't repeat yourself (중복 배제 원칙)
    -   반복을 제거하면 로직을 바꿔야 할 때 여러 곳의 코드를 바꿔야 할 필요가 없어진다.
-   **SRP** : single responsibility principle (**단일 책임 원칙**)
    -   한 클래스는 한 기능만 책임진다.
    -   클래스가 바뀌어야 하는 이유는 오직 하나여야 한다.
-   principle of least surprise (놀람 최소화의 법칙)
    -   메서드를 구현할 때 - 메서드가 수행하는 일을 바로 이해할 수 있도록 자체 문서화를 제공하는 메서드명을 사용한다. (예를 들어 `calculateTokenAmount()`와 같은 메서드명)
    -   코드의 다른 부분이 파라미터의 상태에 의존할 수 있으므로 파라미터의 상태를 바꾸지 않는다.
-   응집도 (cohesion)
    -   서로 **어떻게 관련되어 있는지**
    -   클래스 수준 응집도

    | 응집도 수준           | 장점                        | 단점                               |
    | --------------------- | --------------------------- | ---------------------------------- |
    | 기능(높은 응집도)     | 이해하기 쉬움               | 너무 단순한 클래스 생성            |
    | 정보(중간 응집도)     | 유지보수 하기 쉬움          | 불필요한 디펜던시                  |
    | 순차(중간 응집도)     | 관련 동작을 찾기 쉬움       | SRP를 위배할 수 있음               |
    | 논리(중간 응집도)     | 높은 수준의 카테고리화 제공 | SRP를 위배할 수 있음               |
    | 유틸리티(낮은 응집도) | 간단히 추가 가능            | 클래스의 책임을 파악하기 어려움    |
    | 시간(낮은 응집도)     | 판단 불가                   | 각 동작을 이해하고 사용하기 어려움 |

    -   메서드 수준 응집도
-   결합도 (coupling)
    -   서로 **어떻게 의존하는지**
    -   인터페이스를 통해 특정 구현에 종속되지 않도록 개선한다.

> `final` 키워드

## 2장 구현

-   SRP 적용 - 책임의 분리
    1.  입력 읽기
    2.  주어진 형식의 입력 파싱
    3.  결과 처리
    4.  결과 요약 리포트

## 2장 정리

-   갓 클래스와 코드 중복은 코드를 추론하고 유지보수하기 어렵게 만드는 요인이다.
-   단일 책임 원칙은 관리하고 유지보수하기 쉬운 코드를 구현하는 데 도움을 준다.
-   응집도는 클래스나 메서드의 책임이 얼마나 강하게 연관되어 있는지를 가리킨다.
-   결합도는 클래스가 다른 코드 부분에 얼마나 의존하고 있느지를 가리킨다.
-   높은 응집도와 낮은 결합도는 유지보수가 가능한 코드가 가져야 할 특징이다.
-   자동화된 테스트 스위트는 소프트웨어가 올바로 동작하며, 코드를 수정해도 잘 동작할 것임을 확신할 수 있고, 프로그램을 쉽게 이해할 수 있도록 도움을 준다.
-   자바 테스트 프레임워크로 JUnit을 활용해 메서드와 클래스의 동작을 테스트 하는 유닛 테스트를 만든다.
-   테스트를 쉽게 이해할 수 있도록 Given-When-Then 패턴으로 유닛 테스트를 세 부분으로 분리하는 것이 좋다.

# 3장 입출금 내역 분석기 확장판

## 3장 요구사항

1.  특정 입출금 내역을 검색할 수 있는 기능. 예를 들어 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기.
2.  검색 결과의 요약 통계를 텍스트, HTML 등 다양한 형식으로 만들기.

## 3장 원칙

-   개방/폐쇄 원칙
    -   기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
    -   코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
    -   결합도가 낮아지므로 코드 유지보수성이 좋아진다.

## 3장 구현

-   갓 인터페이스 (god interface)
    -   자바의 인터페이스는 모든 구현이 지켜야 할 규칙을 정의한다. 즉 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야 한다. 따라서 인터페이스를 바꾸면 이를 구현한 코드도 바뀐 내용을
        지원하도록 갱신되어야 한다. 더 많은 연산을 추가할수록 더 자주 코드가 바뀌며, 문제가 발생할 수 있는 범위도 넓어진다.
    ```java
    interface BankTransactionProcessor {
        double calculateTotalAmount();
        double calculateTotalInMonth(Month month);
        double calculateTotalInJanuary();
        double calculateAverageAmount();
        double calculateAverageAmountForCategory();
        List<BankTransaction> findTransactions(BankTransactionFilter bankTransactionFilter);
    }
    ```
    -   월, 카테고리 같은 `BankTranscaction`의 속성이 `calculateAverageForCategory()`, `calculateTotalInJanuary()`처럼 메서드 이름의 일부로 사용되었다. 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생겼다. 도메인 객체의 세부 내용이 바뀌면 인터페이스도 바뀌어야 하며 결과적으로 구현 코드도 바뀌어야 한다.

-   지나친 세밀함 (작은 인터페이스)

    ```java
    interface CalculateTotalAmount {
        double calculateTotalamount();
    }
    
    interface CalculateAverage {
        double calculateAverage();
    }
    
    interface CalculateTotalInMonth {
        double calculateTotalInMonth(Month month);
    }
    ```

    -   유지 보수에 방해가 된다.
    -   **안티 응집도** 문제가 발생한다. 즉 기능이 여러 인테페이스로 분산되어 찾기가 어렵다.
    -   복잡도가 높아지고, 계속적으로 새로운 인터페이스가 추가된다.
-   명시적 API vs 암묵적 API
    -   구체적인 메서드는 자체적으로 어떤 동작을 수행하는지 잘 설명되어 있고, 사용하기 쉽다. 하지만 특정 상황에 국한되어 각 상황에 맞는 새로운 메서드를 많이 만들어야 하는 상황이 발생한다.
    -   범용적인 메서드는 처음 사용하기가 어렵고, 문서화를 잘해놓아야 한다. 하지만 거의 모든 상황을 단순한 API로 처리할 수 있다.
    -   범용적인 메서드를 제공하면서 가장 흔히 사용하는 연산의 경우 별도로 명시적으로 제공하는 것이 합리적이다.
-   도메인 클래스 vs 원싯값
    -   원싯값 반환은 일반적으로 좋은 방법이 아니다. 원싯값으로는 다양한 결과를 반환할 수 없어 유연성이 떨어지기 때문이다. 다양한 결과를 포함하도록 메서드 시그니처를 바꾸려면
        모든 `BankTransactionProcessor`의 구현을 바꿔야 한다.
    -   `double`을 감싸는 새 도메인 클래스 `Summary`를 만들면 문제를 해결할 수 있다. 필요한 필드와 결과를 언제든 추가할 수 있다. 이 기법을 이용하면 도메인의 다양한 개념 간의 결합을
        줄이고, 요구 사항이 바뀔 때 연쇄적으로 코드가 바뀌는 일도 최소화할 수 있다.
-   예외 처리